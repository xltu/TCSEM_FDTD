TCSEM_FDTD calculates the time domain electromagnetic response generated by a bipole source in the
subsurface. 
@Xiaolei Tu
@tuxl2009@hotmail.com

++++++++++++++++++++++++++++++++++Developer's Guide++++++++++++++++++++++++++++++++++++++++++++++++++++++
!!!!!For developer's record, general user may skip this section
 
Explicit scheme finite difference method, the finite difference scheme is Dufort_franckel scheme, as in 
the paper by Tsili Wang (1993).

I approximate the impulse source with a gaussian function

Currently, this no on boundary condition in this version of code

The air-earth interface is computed with the upward continuation method by Tsili Wang (1993)

This version of code is based on previous version of TCSEM_FDTD_GaussiainSr, but parallelized with openMP

The fftw is also a multi-thread version to allow further speedup


Add comments below if you made any change to the code for record tracking's purpose 
@Nov. 30, 2020 @Xiaolei 
Create a more easily accessible inteface for the I/O of the program
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++



----------------------------------------------------------------------------------------------------------	
									  SKIP EVERYTHING ABOVE
#########################################   USER GUIDE  ###################################################
-----------------------------------------------------------------------------------------------------------
TCSEM_FDTD is a time domain finite difference code to simulate the time domain electromagnetic field generate
by a bipole galvanic source in the subsurface or seawater. The source could be a horizontal or vertical bipole.
The code simulate the impulse response to represent the explosive transmitter. That is to say, the simulated 
EM fields are corresponding to a dirac delta source function. The response geneated by any other source function
could obtained by simply convolution of the  simpulated impulse response with the source function.

The code has two levels of parallization. The first level of prallelization is by Tx position. The modeling tasks for  
different Tx position are allocated to different MPI processors. The second level is by domain and for matrix
and vector operations using OpenMP. If there is only one Tx location, there would be only one MPI processor.

============================================================================================================
										Installation
This program requires the following three librarys, MPI, OpenMP, and fftw3. Note that, I use a multi-thread
version of the fftw3. The user should make sure that the three librarires are properly installed on your local
machine. 

The is a makefile in /src subdirection. The users should set the paths to those libs based on their local
environment if they want to compile their local version of the code. After seting up the path in the makefile
the author could change to the /src directory and just type 

make all

in the terminal. The monitor will print corresponding information about whether the program has been
successfully installed. 

Note that the makefile is setup for Linux based machines. But it should be sample to modified it for a 
Windows based machine. 
										
I provide an example of the input files in the /Example subdirectory.  The user should be able to run the
example if the code is compiled in the right way.

To run the code, you will need to setup the input files properly and setup environment veriables for MPI
and OpenMP. I provide shell script 'runFDTDJob.sh' in the example folder for job submition without a job
scheduler. Refer to the script for detailed information on each parameter. The user should consult their
scheduler's manual for submiting job with a job scheduler.


============================================================================================================
									Model parameterization and discritization
The EM fields are calculated on the staggered grids and interpolated to the receiver positions. The grid size
are usually uniform within the source region and then increase exponentially outward by a multiplication factor
(e.g., 1.1). The current version of the code does not automatically generate the grid and discretize the model.
The users have should design their own discreting grid and feed it to the code. The following shows a diagram
of irregular grid in the x direction: there are Lx cells in the center area with uniform grid size of dx; to 
the left area the grid size increase exponentialy by a factor of 1.1 and the number of number of cell in this
region is La; to the right there are too Lb cells with exponentialy incereasing grid size. So the totally number
of cell in the x direction is La+Lb+Lx; 

|<---------------------La cell---------------------->|<---------Lx cell----->|<----------------------Lb cell---------------------------------->|

|----1.1^La*dx----|---1.1^(La-1)*dx---|...|--1.1*dx--|-dx-|-dx-|...|-dx-|-dx-|--1.1*dx--|--1.1^2*dx--|...|---1.1^(Lb-1)*dx---|----1.1^Lb*dx----|

|<-----grid size exponentially increases------------>|<----uniform grid----->|<----------------grid size increases exponentially-------------->|   

 
In the y direction, the grid size follows the same pattern of x direction. But the number of cells in the irregular
grid regions are required to be the same to the left and to the right. The toally number of cells in y direction
is My+2*Ma as shown in the following diagram

|<---------------------Ma cell---------------------->|<---------My cell----->|<----------------------Ma cell---------------------------------->|

|----1.1^Ma*dy----|---1.1^(Ma-1)*dy---|...|--1.1*dy--|-dy-|-dy-|...|-dy-|-dy-|--1.1*dy--|--1.1^2*dy--|...|---1.1^(Ma-1)*dy---|----1.1^Ma*dy----|

|<-----grid size exponentially increases------------>|<----uniform grid----->|<----------------grid size increases exponentially-------------->|   


in the z direction, the grid size is uniform in the water and shallow sediments, and then increase 
exponentially in the deeper area. As demonstrated in the following diagram, the totaly number of grid
in the z direction is Ny+Na.
		-------------------------------------------
			|				|				|
			|				dz				|
			|				|				|
			|			---------			|
			|				|				|
			|				dz				|
			|				|				|
		 Ny	cells		---------		uniform grid	
			|				.				|
			|				.				|
			|				.				|
			|			---------			|	
			|				|				|
			|				dz				|
			|				|				|
		------------------------------------------ 
			|				|				|
			|			 1.1*dz				|
			|				|				|
			|			---------			|
			|				|				|
			|				|				|
			|			 1.1^2*dz			|
			|				|				|
			|				|				|
			|			---------			|
			|				.				|
			|				.				|
		Na cells			.		grid size exponentially increases
			|			---------			|		 
 			|				|				|
			|				|				|
			|			 1.1^(Na-1)*dz		|
			|				|				|
			|				|				|	
			|			---------			|
			|				|				|
 			|				|				|
			|				|				|
			|			 1.1^Na*dz			|
			|				|				|
			|				|				|
			|				|				|
		------------------------------------------

A matlab script is provided in the subdirectory /Mfiles to help generate the grid and models 
for this code. 

================================================================================================================
										Input files
The TCSEM_FDTD program require four input files to be able to run a modeling. The four files are modeling setup
file 'FDTD_setup.in'; Conductivity file 'Cond.bin'; Transmitter file 'Transmitter.in'; and receiver file 'Receiver.in'.
'FDTD_setup.in','Transmitter.in','Receiver.in' are ascii files; and 'Cond.bin' is binary file.

Those file names are fixed and exclusively defined for the program. The following sections give detailed information
on each of the four files. I also provide matlab scripts in the subdirectory /Mfiles to help create those files.


=================================================================================================================
												FDTD_setup.in
The file 'FDTD_setup.in' is mainly used for controlling the TCSEM_FDTD modeling and setup the modeling grid. The file
name of 'FDTD_setup.in' is exclusively defined and fixed. That is, it should be exactly the same as 'FDTD_setup.in'.
It is an ascii format file. The following is a example of the file:

2.0	2.0
200 1.0e-3
0.0 0.0 0.0
50.0 50.0 50.0
1.1 1.2
10 40 120 40 10
10 40 100
10 40 60

First line: two float numbers. The first float number (i.e., 2.0) defines how much speed up you want to push the code. This 
	is done by increasing the time stepping step length through multiplying it with this speed up factor. I could 
	usually be a float number between 1.0-3.0. The larger this factor, the larger the time steps, which would 
	result in less total time iterations and faster modeling speed. But the larger the factor is, the more unstable
	the program is. If you have no idea how to play with it, just set it to 2.0. 
	The seond float number (i.e., 2.0) represents the stablizing factor. The larger it is, the more stable the program is. But 
	a larger stablizing factor will end up with reduced modeling accuracy. Normally, a float number between 1.0-3.0
	is reasonable.
	
Second line: an integer and a float number defining the impulse source. I approximate the time domain impulse source
	(i.e., an exploration) with a time domain Gaussian function. This two numbers control the shape and discritization
	of the Gaussian function. This first integer number (200) represents how many discretizing time steps are used to
	discrtize the Gaussian function. A large number means higher numerical accuracy but more computational expensive.
	A number between 150-400 seems reasonable for most cases. 
	The second float number (i.e.,1.0e-3) defines the bandwith of the Gaussian function. The smaller it is, the more
	flat the Gaussian function's spectrum is. But again, it will be more computational expensive to have a very small value (i.e., 
	larger bandwidth). The unit of this number is second. The 1.0e-3 would produce a flat spectrum
	for frequency below 200Hz. This number could be some float between 1e-6 to 5e-3. For MCSEM, a number from 1e-4 to 2e-3 
	seems good enough. 
	
Third line: three float numbers defining the origin coordinates (x0,y0,z0) of the modeling grids. The first two numbers are 
	the x and y coordinates for the center point of the uniform grid region. For example, for grid setting up as the following diagram,
	x0 is the x coordinate in the middle between the 110th cell and the 111th cell in the x direction.  y0 is the y coordinate
	in the middle between the 100th and 101th cells in the y direction. Note that if you have odd number of cells in the center
	uniform grid region, these two numbers would be the coordinates of a cell center (a cell is located exactly in the center of
	this uniform grid region). 
	The third float z0 is the coordinate of the seasurface, which is usually 0. 
	 
	
cell numbers(first row) and cell size (second row) in x direction	
|<-------10 cells------->|<--------40 cells------>|<--------120 cells----->|<-------40 cells------->|<-------10 cells--------->|

|<--dx=50*1.1^40*1.2^i-->|<------dx=50*1.1^j----->|<-------dx=50---------->|<------dx=50*1.1^j----->|<---dx=50*1.1^40*1.2^i--->|
															 x0
												    This is x0's coordinate																							


cell numbers(first row) and cell size (second row) in y direction
|<-------10 cells------->|<--------40 cells------>|<--------100 cells----->|<-------40 cells------->|<-------10 cells--------->|

|<--dy=50*1.1^40*1.2^i-->|<------dy=50*1.1^j----->|<-------dy=50---------->|<------dy=50*1.1^j----->|<---dy=50*1.1^40*1.2^i--->|
															 y0
												    This is y0's coordinate	


cell numbers(first row) and cell size (second row) in z direction (depth, downward positive)
|<--------60 cells----->|<-------40 cells------->|<-------10 cells--------->|

|<-------dz=50---------->|<------dz=50*1.1^j----->|<---dz=50*1.1^40*1.2^i--->|
z0
z0 is the sea level and is almost always 0. 	
	 	      	    
											
Fourth line: three float number. The smallest cell size (cell size in the uniformly discritized region) in the x, y, and z 
	direction. The units are in meters. 

Fifth line: two float number denoting two grid size exponentially increasing factor. They could be the same. Their value could
 	be a float number between 1.0 - 1.25. As shown in the diagram above, I use two different exponential factors to increase
 	the grid size for cells away from the central region. Taking the x direction for example, there are 120 cells in the
 	center region with equal cell size of 50 m. Moving to the left or right of that region, there are 40 cells to each side,
 	with cell size increases by a factor of 1.1. Beyond those region, the cell size increase more aggressively with a
 	factor of 1.2. Check the the 'Model parameterization and discritization' section for more detailed introduction on
 	cell size exponential increase. 
 	Note that this two exponential increase factors could be the same.
 	
Sixth line: five integer numbers. They represent the numbers of cells in each region of the discretization. For this
	example, they represent the five numbers from left to right as shown in the diagrams above. Note that, the cell numbers
	of exponentially increased size in the left side could be different from those in the right size

seventh line: three integer numbers. Similar to that of the sixth line. But I enforce the y direction grid discrtization
	to be symmetric, so only the first three numbers are kept.
	
eighth line: same as the above line


There is a matlab script in the /Example folder to help generating this input file 		 	   											
											
									
==================================================================================================================
												Cond.bin											
Cond.bin is a binary file contains the conductivity model. It's binary instead of ascii formated just for the sake 
of quick read and write and also to minimize the volume of the file. The grid for the model is defined in the 
FDTD_setup.in file. For example, if you have L*M*N cells in the x,y,and z directions, the file will contains L*M*N
float numbers saved in binary format. Their percisions are 64 bits floating point, corresponding to 'double' in C
and matlab, 'real*8' in Fortran. The model is saved so that the index changes fastest in the x direction, and
slowest in the z direction. The following is a block of pseudo code to read or write the Cond.bin file:

/*  for a 3-D conductivity array Cond[N][M][L], where N,M,L are the number of cells in the z,y,and x directions
	The following pseudo code block is about how to read or write the data from/to a file */
	
	for iz=1:1:N		 // loop over z direction index	
		for iy=1:1:M     // loop over y direction index
			for ix=1:1:L // loop over x direction index
				write(Cond[iz][iy][ix],'double');
				read(Cond[iz][iy][ix],'double');
			end
		end
	end 
      										
There is also a matlab script in the /Example to create this Cond.bin file 


=================================================================================================================
												Receiver.in
File Receiver.in contains the information about the receivers. Its file name is exclusively defined and Fixed. That 
is it should be exactly the same as 'Receiver.in'. It is an ascii file. The following is an example of the Receiver.in
file. The same example is also located in subdirectory /Example.

0.01 10.0		
100 1			
1 1 0 1 1 1
5
1  1500.0 0.0 1000.0
2  2000.0 0.0 1000.0
3  2500.0 0.0 1000.0
4  3000.0 0.0 1000.0
5  3500.0 0.0 1000.0
 
First line: containts two float numbers. They are the range (min and max) of the time series within which the EM 
fields are recorded by the Rx (in second). That is, the first number is the begin time the time records and the second number denotes
the time the receivers stop recording.

Second line: two integers. First integer is the total number of recorded time channels (discrete samples) per 
component per receiver. In the current version of the code, all receiver and all components (Ex,Ey,...,Bz) are set 
to sampling at the same rate. The second integer reprents wheter the sampling records in time domain are logrithmically equally
distributed within the time range (i.e., numbers in the first line). It could be 0 or 1. If it is 0, the sampling time are
linearly uniformly distributed. Otherwise, it is logrithmically distributed.

Thrid line: Six integers corresponding to the six components of EM field: Ex, Ey, Ez, Bx, By, Bz. They represent whether the
receivers record the corresponding components. They could be set as 0 or 1. Zero means that the corresponding component is
NOT recorded by all receivers, otherwise all receivers record the component of EM field.

Fourth line:  a integer, the totally number of receivers

Fifth line:  a interger and three float numbers. The integer denote the receiver ID. The integer should be a positive integer
small than or equal to the total number of receivers. The three float numbers are the x, y, z coordinates of the receiver in meter. 
...
The similar line  as of the fifth repeats for each receiver till the end of the file


================================================================================================================================
											Transmitter.in
File 'Transmitter.in' contains the information of transmitter positions and the receiver IDs. Its an ascii format file. The 
current version of the code support arbitrary number of horizontal or vertial bipole transmitters. I recommand to put the
the transmitter positions to the central area of the modeling domain to avoid any numerical accuracy issues. As in the model
discretization section, the transmitter should be in the region of uniformed grid size.

I will use the following example to explain the format of the transmitter file. Note that, the same example is also contained
in the /Example subfolder. A matlab script in /Example would help to generate the transmitter file automatically.

1
1 1 200.0 0.0 0.0 600.0 5 1 2 3 4 5

First line: integer, the number of transmitter positions

Second line: integer, integer, float, float, float, float, integer, a integer array
The first integer is the transmitter ID, which should be a positive integer between 1 and the totally number of transmitters. 
The second integer represents the orentation of the transmitter. It could be orented to x direction, y direction, and z 
direction, which are represented by a integer value of 1, 2, and 3 respectivelly.
The third to the fifth numbers are float type numbers, which represent the position (coordinates) of the bipole's center.
The sixth number is a float type number denoting the bipole length in meter.
The seventh number is the number of receivers that have recorded the current transmitter's signal. It should be a integer no larger
than the total number of receivers.
Following that is an array of integers whose demension is defined by the seventh integer number. Each of the element in this
array represent one receiver ID. The receiver IDs are contained in the receiver file.

...
if you have more than one transmitter position, you should repeat the second line for each of the transmitter position till 
the end of the file.


===================================================================================================================================   
       										Output file
Output files are saved in binary format for speed reason. They are named 'Tx*.bout', where * represents the transmitter ID. For
each transmitter position, there is a separate output file. 
The first three numbers are integers, saved in 'int' format in C, or correspondingly 'int32' in matlab and 'integer*4' in fortran.
These three integers represented the number of receivers (NRx) recorded the EM fields generated from current transmitter position;
the number of EM components (Ex,Ey,Ez,Bx,By,Bz, Ncomp) recorded by the receivers; and the number of time sampling points  (Nt) for all 
components/receivers.

After that, it a three dimensional matrix with the size of [Nt][Ncomp][NRx] of the recorded EM data. Their percisions are 64 bits 
floating point, corresponding to 'double' in C and matlab, 'real*8' in Fortran. The data is saved so that the index changes fastest
 in sampling times, and slowest in the receiver ids. The following is a block of pseudo code to read or write the Tx*.bout file:  
 
 	
 	read(NRx,'int32');
 	read(Ncomp,'int32');
 	read(Nt,'int32')
 	for iz=1:1:NRx		 		// loop over receiver ids	
		for iy=1:1:Ncomp     	// loop over component index
			for ix=1:1:Nt 		// loop over time sampling index
				read(data[iz][iy][ix],'double');
			end
		end
	end 


A matlab scripte in the /Mfiles is also provided to load in the data to matlab
   
   


  										
										





